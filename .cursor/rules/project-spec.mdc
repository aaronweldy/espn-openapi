---
description:
globs:
alwaysApply: true
---
Your job is to create an OpenAPI schema (v3.0.0) for the entire ESPN API. Endpoints that have not been implemented in @CHECKLIST.md should be your first priority.

Use the following two links as a reference:
- https://gist.github.com/akeaswaran/b48b02f1c94f873c6655e7129910fc3b
- https://github.com/pseudo-r/Public-ESPN-API

Use those files to find the entire set of endpoints you need to generate schemas for.

Your workflow should look like the following:
1. Find an endpoint that is not documented in @spec.yaml.
2. Fetch that endpoint to get an example JSON response. Put this in @json_output. ACTUALLY CURL THE ENDPOINT
3. Use `quicktype` (npx quicktype) on the JSON response to generate a JSON schema object. Example:
  - `npx quicktype --src json_output/core_nfl_boxscore.json --src-lang json --lang schema --out json_schema/core_nfl_boxscore_schema.json`
4. Convert the generated JSON schema object with the relevant OpenAPI spec, adding spec details for the endpoint.
5. Add definitions for those models, and run `make openapi` (potentially with a more specific command)
6. Test the model definitions by making an API call to the new route using the generated Python models in a new test file. (run with `uv run espn-api/tests/test-api.py`). Make sure the fields are populated as expected. Use the GENERATED API CLIENt. Put tests in @tests. Use other tests as an example. 
7. If anything goes wrong in your test, repeat steps 2-6 again.
8. If you find an endpoint in a $ref param that is not in @CHECKLIST.md, add it to the list.
9. Once you have fully verified that the new generated types work, check off the endpoint in @CHECKLIST.md, make a git commit with the changes, and then pick a new endpoint and start again. Make a Git commit with the new changes. Do NOT consider your job complete until your tests can fully parse the API response with the generated codes.

If you need to inspect JSON, use JQ. Read the JQ documentation from context7 if you need to.

YOU CANNOT MODIFY MODEL CODE DIRECTLY. NEVER MODIFY ANYTHING IN MODELS/ YOURSELF.

Keep going until you have a comprehensive OpenAPI spec of all endpoints. Feel free to fetch API routes directly, if it's helpful.

## Important Notes on Model Usage

### Working with Models and UNSET Values
- In the generated models, optional fields are represented with the `UNSET` value when not present.
- `UNSET` is falsy in boolean contexts, so you can simplify conditionals by directly using the field in an if statement:
  - Use `if field_name:` instead of `if field_name is not UNSET:`
  - This makes the code cleaner and more readable
- When accessing nested properties, make sure the parent object exists and is not UNSET before accessing its properties:
  ```python
  # Good practice:
  if player.position and player.position.abbreviation:
      position_str = f"({player.position.abbreviation})"
  ```
- Remember that camelCase JSON fields are converted to snake_case in the Python models.
  - API returns `firstName`, but access as `first_name` in Python

### Working with JSON

Use the `jq` terminal command to parse long JSON output.

### Handling $ref-only Objects

- **Problem**: Some API responses may return an object containing only a `$ref` key (e.g., `"team": { "$ref": "..." }`) where the OpenAPI schema might expect a full object based on the component definition (e.g., `#/components/schemas/Team`). This can lead to `KeyError` during model parsing if the model's `from_dict` expects fields that are not present in the `$ref`-only object.
- **Solution**: Use the `oneOf` keyword in the OpenAPI specification where this might occur.
  1. Define a generic `Reference` schema in your `components/schemas`:
     ```yaml
     Reference:
       type: object
       properties:
         $ref:
           type: string
           format: uri
       required:
         - $ref
     ```
  2. In the schema where a field might be a full object or just a reference (e.g., the `team` field in `AthleteDetailsResponse`), use `oneOf`:
     ```yaml
     properties:
       team:
         oneOf:
           - $ref: '#/components/schemas/Team' # Reference to the full Team schema
           - $ref: '#/components/schemas/Reference' # Reference to the generic Reference schema
     ```
  3. Keep the base schema definition (e.g., `Team`) strict, requiring its normal fields. The `oneOf` provides the flexibility.
- **Usage in Code**: When accessing a field defined with `oneOf` (like `data.team` above), the resulting Python object could be either a `Team` instance or a `Reference` instance. You **must** check the type before accessing attributes specific to the full object:
  ```python
  from models.your_api_client.models.team import Team
  from models.your_api_client.models.reference import Reference
  from models.your_api_client.types import UNSET

  # ... fetch data ...

  if data.team:
      if isinstance(data.team, Team) and data.team.display_name:
          print(f"Team Name: {data.team.display_name}")
      elif isinstance(data.team, Reference) and data.team.ref:
          print(f"Team Reference URL: {data.team.ref}")
      else:
          print("Team information unavailable or in unexpected format")

  ```